"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = _interopRequireDefault(require("lodash.memoize"));

var _Lint = require("../Lint");

var _Versioning = _interopRequireWildcard(require("../Versioning"));

var _providers = require("../providers");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getName(node) {
  switch (node.type) {
    case 'NewExpression':
      {
        return node.callee.name;
      }

    case 'MemberExpression':
      {
        return node.object.name;
      }

    case 'CallExpression':
      {
        return node.callee.name;
      }

    default:
      throw new Error('not found');
  }
}

function generateErrorName(rule) {
  if (rule.name) return rule.name;
  if (rule.property) return `${rule.object}.${rule.property}()`;
  return rule.object;
}

const getPolyfillSet = (0, _lodash.default)(polyfillArrayJSON => new Set(JSON.parse(polyfillArrayJSON)));

function isPolyfilled(context, rule) {
  if (!context.settings.polyfills) return false;
  const polyfills = getPolyfillSet(JSON.stringify(context.settings.polyfills));
  return (// v2 allowed users to select polyfills based off their caniuseId. This is
    // no longer supported. Keeping this here to avoid breaking changes.
    polyfills.has(rule.id) || // Check if polyfill is provided (ex. `Promise.all`)
    polyfills.has(rule.protoChainId) || // Check if entire API is polyfilled (ex. `Promise`)
    polyfills.has(rule.protoChain[0])
  );
}

const getRulesForTargets = (0, _lodash.default)(targetsJSON => {
  const targets = JSON.parse(targetsJSON);
  const result = {
    CallExpression: [],
    NewExpression: [],
    MemberExpression: []
  };

  _providers.rules.forEach(rule => {
    if (rule.getUnsupportedTargets(rule, targets).length === 0) return;
    result[rule.astNodeType].push(rule);
  });

  return result;
});
var _default = {
  meta: {
    docs: {
      description: 'Ensure cross-browser API compatibility',
      category: 'Compatibility',
      url: 'https://github.com/amilajack/eslint-plugin-compat/blob/master/docs/rules/compat.md',
      recommended: true
    },
    fixable: 'code',
    schema: []
  },

  create(context) {
    // Determine lowest targets from browserslist config, which reads user's
    // package.json config section. Use config from eslintrc for testing purposes
    const browserslistConfig = context.settings.browsers || context.settings.targets || context.options[0];
    const browserslistTargets = (0, _Versioning.Versioning)((0, _Versioning.default)(context.getFilename(), browserslistConfig)); // Stringify to support memoization; browserslistConfig is always an array of new objects.

    const targetedRules = getRulesForTargets(JSON.stringify(browserslistTargets));
    const errors = [];

    function handleFailingRule(rule, node) {
      if (isPolyfilled(context, rule)) return;
      errors.push({
        node,
        message: [generateErrorName(rule), 'is not supported in', rule.getUnsupportedTargets(rule, browserslistTargets).join(', ')].join(' ')
      });
    }

    const identifiers = new Set();
    return {
      CallExpression: _Lint.lintCallExpression.bind(null, handleFailingRule, targetedRules.CallExpression),
      NewExpression: _Lint.lintNewExpression.bind(null, handleFailingRule, targetedRules.NewExpression),
      MemberExpression: _Lint.lintMemberExpression.bind(null, handleFailingRule, targetedRules.MemberExpression),

      // Keep track of all the defined variables. Do not report errors for nodes that are not defined
      Identifier(node) {
        if (node.parent) {
          const {
            type
          } = node.parent;

          if ( // ex. const { Set } = require('immutable');
          type === 'Property' || // ex. function Set() {}
          type === 'FunctionDeclaration' || // ex. const Set = () => {}
          type === 'VariableDeclarator' || // ex. class Set {}
          type === 'ClassDeclaration' || // ex. import Set from 'set';
          type === 'ImportDefaultSpecifier' || // ex. import {Set} from 'set';
          type === 'ImportSpecifier' || // ex. import {Set} from 'set';
          type === 'ImportDeclaration') {
            identifiers.add(node.name);
          }
        }
      },

      'Program:exit': () => {
        // Get a map of all the variables defined in the root scope (not the global scope)
        // const variablesMap = context.getScope().childScopes.map(e => e.set)[0];
        errors.filter(error => !identifiers.has(getName(error.node))).forEach(node => context.report(node));
      }
    };
  }

};
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ydWxlcy9jb21wYXQuanMiXSwibmFtZXMiOlsiZ2V0TmFtZSIsIm5vZGUiLCJ0eXBlIiwiY2FsbGVlIiwibmFtZSIsIm9iamVjdCIsIkVycm9yIiwiZ2VuZXJhdGVFcnJvck5hbWUiLCJydWxlIiwicHJvcGVydHkiLCJnZXRQb2x5ZmlsbFNldCIsInBvbHlmaWxsQXJyYXlKU09OIiwiU2V0IiwiSlNPTiIsInBhcnNlIiwiaXNQb2x5ZmlsbGVkIiwiY29udGV4dCIsInNldHRpbmdzIiwicG9seWZpbGxzIiwic3RyaW5naWZ5IiwiaGFzIiwiaWQiLCJwcm90b0NoYWluSWQiLCJwcm90b0NoYWluIiwiZ2V0UnVsZXNGb3JUYXJnZXRzIiwidGFyZ2V0c0pTT04iLCJ0YXJnZXRzIiwicmVzdWx0IiwiQ2FsbEV4cHJlc3Npb24iLCJOZXdFeHByZXNzaW9uIiwiTWVtYmVyRXhwcmVzc2lvbiIsInJ1bGVzIiwiZm9yRWFjaCIsImdldFVuc3VwcG9ydGVkVGFyZ2V0cyIsImxlbmd0aCIsImFzdE5vZGVUeXBlIiwicHVzaCIsIm1ldGEiLCJkb2NzIiwiZGVzY3JpcHRpb24iLCJjYXRlZ29yeSIsInVybCIsInJlY29tbWVuZGVkIiwiZml4YWJsZSIsInNjaGVtYSIsImNyZWF0ZSIsImJyb3dzZXJzbGlzdENvbmZpZyIsImJyb3dzZXJzIiwib3B0aW9ucyIsImJyb3dzZXJzbGlzdFRhcmdldHMiLCJnZXRGaWxlbmFtZSIsInRhcmdldGVkUnVsZXMiLCJlcnJvcnMiLCJoYW5kbGVGYWlsaW5nUnVsZSIsIm1lc3NhZ2UiLCJqb2luIiwiaWRlbnRpZmllcnMiLCJsaW50Q2FsbEV4cHJlc3Npb24iLCJiaW5kIiwibGludE5ld0V4cHJlc3Npb24iLCJsaW50TWVtYmVyRXhwcmVzc2lvbiIsIklkZW50aWZpZXIiLCJwYXJlbnQiLCJhZGQiLCJmaWx0ZXIiLCJlcnJvciIsInJlcG9ydCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUNBOztBQUNBOztBQUtBOztBQUVB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RUFBRThCLDJCQUFxQkYsSUFBckIsQ0FDaEIsSUFEZ0IsRUFFaEJMLGlCQUZnQixFQUdoQkYsYUFBYSxDQUFDckIsZ0JBSEUsQ0FYYjs7QUFnQkw7QUFDQStCLE1BQUFBLFVBQVUsQ0FBQzVELElBQUQsRUFBbUI7QUFDM0IsWUFBSUEsSUFBSSxDQUFDNkQsTUFBVCxFQUFpQjtBQUNmLGdCQUFNO0FBQUU1RCxZQUFBQTtBQUFGLGNBQVdELElBQUksQ0FBQzZELE1BQXRCOztBQUNBLGVBQ0U7QUFDQTVELFVBQUFBLElBQUksS0FBSyxVQUFULElBQ0E7QUFDQUEsVUFBQUEsSUFBSSxLQUFLLHFCQUZULElBR0E7QUFDQUEsVUFBQUEsSUFBSSxLQUFLLG9CQUpULElBS0E7QUFDQUEsVUFBQUEsSUFBSSxLQUFLLGtCQU5ULElBT0E7QUFDQUEsVUFBQUEsSUFBSSxLQUFLLHdCQVJULElBU0E7QUFDQUEsVUFBQUEsSUFBSSxLQUFLLGlCQVZULElBV0E7QUFDQUEsVUFBQUEsSUFBSSxLQUFLLG1CQWRYLEVBZUU7QUFDQXNELFlBQUFBLFdBQVcsQ0FBQ08sR0FBWixDQUFnQjlELElBQUksQ0FBQ0csSUFBckI7QUFDRDtBQUNGO0FBQ0YsT0F2Q0k7O0FBd0NMLHNCQUFnQixNQUFNO0FBQ3BCO0FBQ0E7QUFDQWdELFFBQUFBLE1BQU0sQ0FDSFksTUFESCxDQUNVQyxLQUFLLElBQUksQ0FBQ1QsV0FBVyxDQUFDcEMsR0FBWixDQUFnQnBCLE9BQU8sQ0FBQ2lFLEtBQUssQ0FBQ2hFLElBQVAsQ0FBdkIsQ0FEcEIsRUFFRytCLE9BRkgsQ0FFVy9CLElBQUksSUFBSWUsT0FBTyxDQUFDa0QsTUFBUixDQUFlakUsSUFBZixDQUZuQjtBQUdEO0FBOUNJLEtBQVA7QUFnREQ7O0FBN0ZZLEMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuaW1wb3J0IG1lbW9pemUgZnJvbSAnbG9kYXNoLm1lbW9pemUnO1xuaW1wb3J0IHtcbiAgbGludENhbGxFeHByZXNzaW9uLFxuICBsaW50TWVtYmVyRXhwcmVzc2lvbixcbiAgbGludE5ld0V4cHJlc3Npb25cbn0gZnJvbSAnLi4vTGludCc7XG5pbXBvcnQgRGV0ZXJtaW5lVGFyZ2V0c0Zyb21Db25maWcsIHsgVmVyc2lvbmluZyB9IGZyb20gJy4uL1ZlcnNpb25pbmcnO1xuaW1wb3J0IHR5cGUgeyBFU0xpbnROb2RlLCBOb2RlLCBCcm93c2VyTGlzdENvbmZpZyB9IGZyb20gJy4uL0xpbnRUeXBlcyc7XG5pbXBvcnQgeyBydWxlcyB9IGZyb20gJy4uL3Byb3ZpZGVycyc7XG5cbnR5cGUgRVNMaW50ID0ge1xuICBbYXN0Tm9kZVR5cGVOYW1lOiBzdHJpbmddOiAobm9kZTogRVNMaW50Tm9kZSkgPT4gdm9pZFxufTtcblxudHlwZSBDb250ZXh0ID0ge1xuICBub2RlOiBFU0xpbnROb2RlLFxuICBvcHRpb25zOiBBcnJheTxzdHJpbmc+LFxuICBzZXR0aW5nczoge1xuICAgIGJyb3dzZXJzOiBBcnJheTxzdHJpbmc+LFxuICAgIHBvbHlmaWxsczogQXJyYXk8c3RyaW5nPlxuICB9LFxuICBnZXRGaWxlbmFtZTogKCkgPT4gc3RyaW5nLFxuICByZXBvcnQ6ICgpID0+IHZvaWRcbn07XG5cbmZ1bmN0aW9uIGdldE5hbWUobm9kZTogRVNMaW50Tm9kZSk6IHN0cmluZyB7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSAnTmV3RXhwcmVzc2lvbic6IHtcbiAgICAgIHJldHVybiBub2RlLmNhbGxlZS5uYW1lO1xuICAgIH1cbiAgICBjYXNlICdNZW1iZXJFeHByZXNzaW9uJzoge1xuICAgICAgcmV0dXJuIG5vZGUub2JqZWN0Lm5hbWU7XG4gICAgfVxuICAgIGNhc2UgJ0NhbGxFeHByZXNzaW9uJzoge1xuICAgICAgcmV0dXJuIG5vZGUuY2FsbGVlLm5hbWU7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBmb3VuZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlRXJyb3JOYW1lKHJ1bGU6IE5vZGUpOiBzdHJpbmcge1xuICBpZiAocnVsZS5uYW1lKSByZXR1cm4gcnVsZS5uYW1lO1xuICBpZiAocnVsZS5wcm9wZXJ0eSkgcmV0dXJuIGAke3J1bGUub2JqZWN0fS4ke3J1bGUucHJvcGVydHl9KClgO1xuICByZXR1cm4gcnVsZS5vYmplY3Q7XG59XG5cbmNvbnN0IGdldFBvbHlmaWxsU2V0ID0gbWVtb2l6ZShcbiAgKHBvbHlmaWxsQXJyYXlKU09OOiBzdHJpbmcpOiBTZXQ8U3RyaW5nPiA9PlxuICAgIG5ldyBTZXQoSlNPTi5wYXJzZShwb2x5ZmlsbEFycmF5SlNPTikpXG4pO1xuXG5mdW5jdGlvbiBpc1BvbHlmaWxsZWQoY29udGV4dDogQ29udGV4dCwgcnVsZTogTm9kZSk6IGJvb2xlYW4ge1xuICBpZiAoIWNvbnRleHQuc2V0dGluZ3MucG9seWZpbGxzKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHBvbHlmaWxscyA9IGdldFBvbHlmaWxsU2V0KEpTT04uc3RyaW5naWZ5KGNvbnRleHQuc2V0dGluZ3MucG9seWZpbGxzKSk7XG4gIHJldHVybiAoXG4gICAgLy8gdjIgYWxsb3dlZCB1c2VycyB0byBzZWxlY3QgcG9seWZpbGxzIGJhc2VkIG9mZiB0aGVpciBjYW5pdXNlSWQuIFRoaXMgaXNcbiAgICAvLyBubyBsb25nZXIgc3VwcG9ydGVkLiBLZWVwaW5nIHRoaXMgaGVyZSB0byBhdm9pZCBicmVha2luZyBjaGFuZ2VzLlxuICAgIHBvbHlmaWxscy5oYXMocnVsZS5pZCkgfHxcbiAgICAvLyBDaGVjayBpZiBwb2x5ZmlsbCBpcyBwcm92aWRlZCAoZXguIGBQcm9taXNlLmFsbGApXG4gICAgcG9seWZpbGxzLmhhcyhydWxlLnByb3RvQ2hhaW5JZCkgfHxcbiAgICAvLyBDaGVjayBpZiBlbnRpcmUgQVBJIGlzIHBvbHlmaWxsZWQgKGV4LiBgUHJvbWlzZWApXG4gICAgcG9seWZpbGxzLmhhcyhydWxlLnByb3RvQ2hhaW5bMF0pXG4gICk7XG59XG5cbmNvbnN0IGdldFJ1bGVzRm9yVGFyZ2V0cyA9IG1lbW9pemUoKHRhcmdldHNKU09OOiBzdHJpbmcpOiBPYmplY3QgPT4ge1xuICBjb25zdCB0YXJnZXRzID0gSlNPTi5wYXJzZSh0YXJnZXRzSlNPTik7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBDYWxsRXhwcmVzc2lvbjogW10sXG4gICAgTmV3RXhwcmVzc2lvbjogW10sXG4gICAgTWVtYmVyRXhwcmVzc2lvbjogW11cbiAgfTtcbiAgcnVsZXMuZm9yRWFjaChydWxlID0+IHtcbiAgICBpZiAocnVsZS5nZXRVbnN1cHBvcnRlZFRhcmdldHMocnVsZSwgdGFyZ2V0cykubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgcmVzdWx0W3J1bGUuYXN0Tm9kZVR5cGVdLnB1c2gocnVsZSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbWV0YToge1xuICAgIGRvY3M6IHtcbiAgICAgIGRlc2NyaXB0aW9uOiAnRW5zdXJlIGNyb3NzLWJyb3dzZXIgQVBJIGNvbXBhdGliaWxpdHknLFxuICAgICAgY2F0ZWdvcnk6ICdDb21wYXRpYmlsaXR5JyxcbiAgICAgIHVybDpcbiAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9hbWlsYWphY2svZXNsaW50LXBsdWdpbi1jb21wYXQvYmxvYi9tYXN0ZXIvZG9jcy9ydWxlcy9jb21wYXQubWQnLFxuICAgICAgcmVjb21tZW5kZWQ6IHRydWVcbiAgICB9LFxuICAgIGZpeGFibGU6ICdjb2RlJyxcbiAgICBzY2hlbWE6IFtdXG4gIH0sXG4gIGNyZWF0ZShjb250ZXh0OiBDb250ZXh0KTogRVNMaW50IHtcbiAgICAvLyBEZXRlcm1pbmUgbG93ZXN0IHRhcmdldHMgZnJvbSBicm93c2Vyc2xpc3QgY29uZmlnLCB3aGljaCByZWFkcyB1c2VyJ3NcbiAgICAvLyBwYWNrYWdlLmpzb24gY29uZmlnIHNlY3Rpb24uIFVzZSBjb25maWcgZnJvbSBlc2xpbnRyYyBmb3IgdGVzdGluZyBwdXJwb3Nlc1xuICAgIGNvbnN0IGJyb3dzZXJzbGlzdENvbmZpZzogQnJvd3Nlckxpc3RDb25maWcgPVxuICAgICAgY29udGV4dC5zZXR0aW5ncy5icm93c2VycyB8fFxuICAgICAgY29udGV4dC5zZXR0aW5ncy50YXJnZXRzIHx8XG4gICAgICBjb250ZXh0Lm9wdGlvbnNbMF07XG5cbiAgICBjb25zdCBicm93c2Vyc2xpc3RUYXJnZXRzID0gVmVyc2lvbmluZyhcbiAgICAgIERldGVybWluZVRhcmdldHNGcm9tQ29uZmlnKGNvbnRleHQuZ2V0RmlsZW5hbWUoKSwgYnJvd3NlcnNsaXN0Q29uZmlnKVxuICAgICk7XG5cbiAgICAvLyBTdHJpbmdpZnkgdG8gc3VwcG9ydCBtZW1vaXphdGlvbjsgYnJvd3NlcnNsaXN0Q29uZmlnIGlzIGFsd2F5cyBhbiBhcnJheSBvZiBuZXcgb2JqZWN0cy5cbiAgICBjb25zdCB0YXJnZXRlZFJ1bGVzID0gZ2V0UnVsZXNGb3JUYXJnZXRzKFxuICAgICAgSlNPTi5zdHJpbmdpZnkoYnJvd3NlcnNsaXN0VGFyZ2V0cylcbiAgICApO1xuXG4gICAgY29uc3QgZXJyb3JzID0gW107XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVGYWlsaW5nUnVsZShydWxlOiBOb2RlLCBub2RlOiBFU0xpbnROb2RlKSB7XG4gICAgICBpZiAoaXNQb2x5ZmlsbGVkKGNvbnRleHQsIHJ1bGUpKSByZXR1cm47XG4gICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgIG5vZGUsXG4gICAgICAgIG1lc3NhZ2U6IFtcbiAgICAgICAgICBnZW5lcmF0ZUVycm9yTmFtZShydWxlKSxcbiAgICAgICAgICAnaXMgbm90IHN1cHBvcnRlZCBpbicsXG4gICAgICAgICAgcnVsZS5nZXRVbnN1cHBvcnRlZFRhcmdldHMocnVsZSwgYnJvd3NlcnNsaXN0VGFyZ2V0cykuam9pbignLCAnKVxuICAgICAgICBdLmpvaW4oJyAnKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgaWRlbnRpZmllcnMgPSBuZXcgU2V0KCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgQ2FsbEV4cHJlc3Npb246IGxpbnRDYWxsRXhwcmVzc2lvbi5iaW5kKFxuICAgICAgICBudWxsLFxuICAgICAgICBoYW5kbGVGYWlsaW5nUnVsZSxcbiAgICAgICAgdGFyZ2V0ZWRSdWxlcy5DYWxsRXhwcmVzc2lvblxuICAgICAgKSxcbiAgICAgIE5ld0V4cHJlc3Npb246IGxpbnROZXdFeHByZXNzaW9uLmJpbmQoXG4gICAgICAgIG51bGwsXG4gICAgICAgIGhhbmRsZUZhaWxpbmdSdWxlLFxuICAgICAgICB0YXJnZXRlZFJ1bGVzLk5ld0V4cHJlc3Npb25cbiAgICAgICksXG4gICAgICBNZW1iZXJFeHByZXNzaW9uOiBsaW50TWVtYmVyRXhwcmVzc2lvbi5iaW5kKFxuICAgICAgICBudWxsLFxuICAgICAgICBoYW5kbGVGYWlsaW5nUnVsZSxcbiAgICAgICAgdGFyZ2V0ZWRSdWxlcy5NZW1iZXJFeHByZXNzaW9uXG4gICAgICApLFxuICAgICAgLy8gS2VlcCB0cmFjayBvZiBhbGwgdGhlIGRlZmluZWQgdmFyaWFibGVzLiBEbyBub3QgcmVwb3J0IGVycm9ycyBmb3Igbm9kZXMgdGhhdCBhcmUgbm90IGRlZmluZWRcbiAgICAgIElkZW50aWZpZXIobm9kZTogRVNMaW50Tm9kZSkge1xuICAgICAgICBpZiAobm9kZS5wYXJlbnQpIHtcbiAgICAgICAgICBjb25zdCB7IHR5cGUgfSA9IG5vZGUucGFyZW50O1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIGV4LiBjb25zdCB7IFNldCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XG4gICAgICAgICAgICB0eXBlID09PSAnUHJvcGVydHknIHx8XG4gICAgICAgICAgICAvLyBleC4gZnVuY3Rpb24gU2V0KCkge31cbiAgICAgICAgICAgIHR5cGUgPT09ICdGdW5jdGlvbkRlY2xhcmF0aW9uJyB8fFxuICAgICAgICAgICAgLy8gZXguIGNvbnN0IFNldCA9ICgpID0+IHt9XG4gICAgICAgICAgICB0eXBlID09PSAnVmFyaWFibGVEZWNsYXJhdG9yJyB8fFxuICAgICAgICAgICAgLy8gZXguIGNsYXNzIFNldCB7fVxuICAgICAgICAgICAgdHlwZSA9PT0gJ0NsYXNzRGVjbGFyYXRpb24nIHx8XG4gICAgICAgICAgICAvLyBleC4gaW1wb3J0IFNldCBmcm9tICdzZXQnO1xuICAgICAgICAgICAgdHlwZSA9PT0gJ0ltcG9ydERlZmF1bHRTcGVjaWZpZXInIHx8XG4gICAgICAgICAgICAvLyBleC4gaW1wb3J0IHtTZXR9IGZyb20gJ3NldCc7XG4gICAgICAgICAgICB0eXBlID09PSAnSW1wb3J0U3BlY2lmaWVyJyB8fFxuICAgICAgICAgICAgLy8gZXguIGltcG9ydCB7U2V0fSBmcm9tICdzZXQnO1xuICAgICAgICAgICAgdHlwZSA9PT0gJ0ltcG9ydERlY2xhcmF0aW9uJ1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWRlbnRpZmllcnMuYWRkKG5vZGUubmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgJ1Byb2dyYW06ZXhpdCc6ICgpID0+IHtcbiAgICAgICAgLy8gR2V0IGEgbWFwIG9mIGFsbCB0aGUgdmFyaWFibGVzIGRlZmluZWQgaW4gdGhlIHJvb3Qgc2NvcGUgKG5vdCB0aGUgZ2xvYmFsIHNjb3BlKVxuICAgICAgICAvLyBjb25zdCB2YXJpYWJsZXNNYXAgPSBjb250ZXh0LmdldFNjb3BlKCkuY2hpbGRTY29wZXMubWFwKGUgPT4gZS5zZXQpWzBdO1xuICAgICAgICBlcnJvcnNcbiAgICAgICAgICAuZmlsdGVyKGVycm9yID0+ICFpZGVudGlmaWVycy5oYXMoZ2V0TmFtZShlcnJvci5ub2RlKSkpXG4gICAgICAgICAgLmZvckVhY2gobm9kZSA9PiBjb250ZXh0LnJlcG9ydChub2RlKSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcbiJdfQ==